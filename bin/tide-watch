#!/usr/bin/env node

/**
 * Tide Watch CLI
 * Manual capacity checks for OpenClaw sessions
 */

const {
  getAllSessions,
  getSession,
  filterByThreshold,
  filterByActivityAge,
  getSessionsOlderThan,
  sortByCapacity,
  formatTable,
  formatJSON,
  formatDashboard,
  formatRelativeTime,
  parseTimeString,
  archiveSessions,
  DEFAULT_SESSION_DIR
} = require('../lib/capacity');

const USAGE = `
Tide Watch üåä - OpenClaw Session Capacity Monitor

USAGE:
  tide-watch check [--session <key>]     Check current or specific session
  tide-watch report [--all]               List all sessions (or above threshold)
  tide-watch dashboard                    Visual dashboard with recommendations
  tide-watch archive --older-than <time>  Archive old sessions
  tide-watch restore-prompt <action>      Manage session restoration prompts
  tide-watch status                       Quick status summary
  tide-watch help                         Show this help

OPTIONS:
  --session <key>      Target a specific session (default: current)
  --all                Show all sessions regardless of capacity
  --threshold <num>    Filter sessions above this percentage (default: 75)
  --active <hours>     Only show sessions active within N hours (e.g., --active 24)
  --older-than <time>  Archive sessions older than time (e.g., 4d, 2w, 1mo)
  --dry-run            Preview archive without making changes
  --exclude-channel    Exclude specific channel from archiving
  --min-capacity <num> Only archive sessions below this capacity (default: no limit)
  --json               Output as JSON instead of table
  --pretty             Pretty-print JSON (requires --json)
  --watch              Live updates (dashboard only, refreshes every 10s)
  --session-dir <path> Custom session directory (default: ~/.openclaw/agents/main/sessions)

EXAMPLES:
  tide-watch check                        # Check current session
  tide-watch check --session abc123       # Check specific session
  tide-watch report                       # Show sessions above 75%
  tide-watch report --all                 # Show all sessions
  tide-watch report --threshold 90        # Show sessions above 90%
  tide-watch dashboard                    # Visual dashboard view
  tide-watch dashboard --active 48        # Only sessions active in last 48 hours
  tide-watch dashboard --watch            # Live updating dashboard
  tide-watch archive --older-than 4d --dry-run    # Preview archiving sessions older than 4 days
  tide-watch archive --older-than 2w              # Archive sessions older than 2 weeks
  tide-watch archive --older-than 1mo --exclude-channel discord  # Archive but keep Discord
  tide-watch restore-prompt edit                  # Edit restoration prompt for current session
  tide-watch restore-prompt show                  # Show current restoration prompt
  tide-watch restore-prompt list                  # List all restoration prompts
  tide-watch status                       # Quick status summary

RESTORE-PROMPT ACTIONS:
  edit                   Open restoration prompt in editor
  show                   Display current restoration prompt
  info                   Show restoration prompt metadata
  list                   List all restoration prompts
  test                   Test restoration prompt (dry-run)
  delete                 Delete restoration prompt
  enable                 Enable auto-loading for session
  disable                Disable auto-loading for session
  status                 Check enabled/disabled state

`.trim();

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2);
  
  const options = {
    command: args[0] || 'help',
    session: null,
    all: false,
    threshold: 75,
    activeHours: null,
    olderThan: null,
    dryRun: false,
    excludeChannel: null,
    minCapacity: null,
    json: false,
    pretty: false,
    watch: false,
    sessionDir: DEFAULT_SESSION_DIR
  };

  for (let i = 1; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--session' && i + 1 < args.length) {
      options.session = args[++i];
    } else if (arg === '--all') {
      options.all = true;
    } else if (arg === '--threshold' && i + 1 < args.length) {
      options.threshold = parseInt(args[++i], 10);
    } else if (arg === '--active' && i + 1 < args.length) {
      options.activeHours = parseInt(args[++i], 10);
    } else if (arg === '--older-than' && i + 1 < args.length) {
      options.olderThan = args[++i];
    } else if (arg === '--dry-run') {
      options.dryRun = true;
    } else if (arg === '--exclude-channel' && i + 1 < args.length) {
      options.excludeChannel = args[++i];
    } else if (arg === '--min-capacity' && i + 1 < args.length) {
      options.minCapacity = parseInt(args[++i], 10);
    } else if (arg === '--json') {
      options.json = true;
    } else if (arg === '--pretty') {
      options.pretty = true;
    } else if (arg === '--watch') {
      options.watch = true;
    } else if (arg === '--session-dir' && i + 1 < args.length) {
      options.sessionDir = args[++i];
    }
  }

  return options;
}

/**
 * Check command: Show capacity for current or specific session
 */
function checkCommand(options) {
  if (options.session) {
    // Check specific session
    const session = getSession(options.session, options.sessionDir);
    
    if (!session) {
      console.error(`‚ùå Session not found: ${options.session}`);
      process.exit(1);
    }
    
    if (options.json) {
      console.log(formatJSON([session], options.pretty));
    } else {
      console.log(`\nSession: ${session.sessionId}`);
      console.log(`Channel: ${session.channel}`);
      if (session.label) {
        console.log(`Label:   ${session.label}`);
      }
      console.log(`Model:   ${session.model}`);
      console.log(`Status:  ${session.status}`);
      console.log(`\nCapacity: ${session.percentage}%`);
      console.log(`Tokens:   ${session.tokensUsed.toLocaleString()} / ${session.tokensMax.toLocaleString()}`);
      console.log(`Messages: ${session.messageCount}`);
      console.log(`Last Activity: ${new Date(session.lastActivity).toLocaleString()}\n`);
      
      // Show recommendations
      if (session.percentage >= 95) {
        console.log('üö® CRITICAL: Session will lock soon! Save to memory and reset immediately.');
      } else if (session.percentage >= 90) {
        console.log('üî¥ HIGH: Recommend finishing current task and resetting session.');
      } else if (session.percentage >= 85) {
        console.log('üü† ELEVATED: Consider wrapping up soon and switching to a fresh session.');
      } else if (session.percentage >= 75) {
        console.log('üü° WARNING: Capacity approaching threshold. Plan to reset soon.');
      } else {
        console.log('‚úÖ OK: Plenty of capacity remaining.');
      }
      console.log('');
    }
  } else {
    // TODO: Detect current session from environment or session file
    console.error('‚ùå --session <key> required for check command');
    console.error('   (Auto-detection of current session not yet implemented)');
    process.exit(1);
  }
}

/**
 * Report command: List all sessions with capacity info
 */
function reportCommand(options) {
  let sessions = getAllSessions(options.sessionDir);
  
  if (sessions.length === 0) {
    console.log('No sessions found.');
    return;
  }

  // Filter by activity age if specified
  if (options.activeHours) {
    sessions = filterByActivityAge(sessions, options.activeHours);
  }

  // Filter by threshold unless --all is specified
  if (!options.all) {
    sessions = filterByThreshold(sessions, options.threshold);
  }

  // Sort by capacity (highest first)
  sessions = sortByCapacity(sessions);

  if (sessions.length === 0) {
    const filters = [];
    if (options.activeHours) filters.push(`active in last ${options.activeHours}h`);
    if (!options.all) filters.push(`above ${options.threshold}%`);
    console.log(`No sessions ${filters.join(' and ')}.`);
    return;
  }

  if (options.json) {
    console.log(formatJSON(sessions, options.pretty));
  } else {
    console.log(`\nTide Watch Report üåä\n`);
    console.log(formatTable(sessions));
    const filterDesc = options.activeHours ? ` (active in last ${options.activeHours}h)` : '';
    console.log(`\nTotal: ${sessions.length} session(s)${!options.all ? ` above ${options.threshold}%` : ''}${filterDesc}\n`);
  }
}

/**
 * Status command: Quick summary
 */
function statusCommand(options) {
  const sessions = getAllSessions(options.sessionDir);
  
  if (sessions.length === 0) {
    console.log('No active sessions.');
    return;
  }

  const total = sessions.length;
  const critical = sessions.filter(s => s.percentage >= 95).length;
  const high = sessions.filter(s => s.percentage >= 90 && s.percentage < 95).length;
  const elevated = sessions.filter(s => s.percentage >= 85 && s.percentage < 90).length;
  const warning = sessions.filter(s => s.percentage >= 75 && s.percentage < 85).length;
  const ok = sessions.filter(s => s.percentage < 75).length;

  console.log(`\nTide Watch Status üåä\n`);
  console.log(`Total Sessions: ${total}`);
  console.log(`  üö® Critical (‚â•95%):  ${critical}`);
  console.log(`  üî¥ High (90-94%):    ${high}`);
  console.log(`  üü† Elevated (85-89%): ${elevated}`);
  console.log(`  üü° Warning (75-84%):  ${warning}`);
  console.log(`  ‚úÖ OK (<75%):         ${ok}\n`);

  if (critical > 0 || high > 0) {
    console.log('‚ö†Ô∏è  Action needed: Run "tide-watch report" for details\n');
  }
}

/**
 * Dashboard command: Visual overview with recommendations
 */
function dashboardCommand(options) {
  const showDashboard = () => {
    let sessions = getAllSessions(options.sessionDir);
    
    if (sessions.length === 0) {
      console.log('\nNo active sessions found.\n');
      return;
    }

    // Filter by activity age if specified
    if (options.activeHours) {
      const beforeFilter = sessions.length;
      sessions = filterByActivityAge(sessions, options.activeHours);
      if (sessions.length === 0) {
        console.log(`\nNo sessions active in the last ${options.activeHours} hours (${beforeFilter} total).\n`);
        return;
      }
    }

    if (options.json) {
      // JSON output includes sessions + recommendations
      const { getRecommendations } = require('../lib/capacity');
      const data = {
        sessions,
        recommendations: getRecommendations(sessions),
        timestamp: new Date().toISOString(),
        filters: {
          activeHours: options.activeHours || null
        }
      };
      console.log(formatJSON(data, options.pretty));
    } else {
      // Clear screen for watch mode
      if (options.watch) {
        console.clear();
        console.log(`Last updated: ${new Date().toLocaleString()}\n`);
      }
      
      // Visual dashboard
      console.log(formatDashboard(sessions));
      
      // Show filter info if active
      if (options.activeHours) {
        console.log(`Showing sessions active in last ${options.activeHours} hours\n`);
      }
    }
  };

  // Show dashboard once
  showDashboard();

  // Watch mode: refresh every 10 seconds
  if (options.watch && !options.json) {
    console.log('üîÑ Watch mode active (refreshes every 10s). Press Ctrl+C to exit.\n');
    setInterval(showDashboard, 10000);
  }
}

/**
 * Archive command: Move old sessions to archive directory
 */
function archiveCommand(options) {
  // Validate required options
  if (!options.olderThan) {
    console.error('‚ùå --older-than <time> is required for archive command');
    console.error('   Example: tide-watch archive --older-than 4d');
    process.exit(1);
  }

  // Parse time string
  let hours;
  try {
    hours = parseTimeString(options.olderThan);
  } catch (error) {
    console.error(`‚ùå ${error.message}`);
    process.exit(1);
  }

  // Get all sessions
  let sessions = getAllSessions(options.sessionDir);
  
  if (sessions.length === 0) {
    console.log('No sessions found.');
    return;
  }

  // Filter to sessions older than threshold
  sessions = getSessionsOlderThan(sessions, hours);
  
  if (sessions.length === 0) {
    console.log(`No sessions older than ${options.olderThan}.`);
    return;
  }

  // Apply exclusion filters
  if (options.excludeChannel) {
    sessions = sessions.filter(s => s.channel !== options.excludeChannel);
  }

  if (options.minCapacity !== null) {
    sessions = sessions.filter(s => s.percentage < options.minCapacity);
  }

  if (sessions.length === 0) {
    console.log(`No sessions match archive criteria.`);
    return;
  }

  // Show what will be/was archived
  if (options.dryRun) {
    console.log(`\n${options.dryRun ? 'Would archive' : 'Archiving'} ${sessions.length} session(s) older than ${options.olderThan}:\n`);
  } else {
    console.log(`\nArchiving ${sessions.length} session(s) older than ${options.olderThan}...\n`);
  }

  // Display table of sessions to archive
  console.log('Session ID  Channel/Label     Last Active  Capacity  Tokens');
  console.log('‚îÄ'.repeat(65));
  
  sessions.forEach(session => {
    const id = session.sessionId.substring(0, 10).padEnd(11);
    const channelLabel = `${session.channel}${session.label ? '/' + session.label : ''}`.substring(0, 16).padEnd(17);
    const lastActive = formatRelativeTime(session.lastActivity).padEnd(11);
    const capacity = `${session.percentage.toFixed(1)}%`.padEnd(9);
    const tokens = session.tokensUsed.toLocaleString();
    
    console.log(`${id} ${channelLabel} ${lastActive} ${capacity} ${tokens}`);
  });
  
  console.log('‚îÄ'.repeat(65));
  console.log('');

  if (options.dryRun) {
    console.log('üîç Dry run mode - no files were modified');
    console.log('   Run without --dry-run to archive\n');
    return;
  }

  // Perform archive
  const results = archiveSessions(sessions, options.sessionDir, options.dryRun);

  // Show results
  if (results.archived.length > 0) {
    console.log(`‚úÖ Archived ${results.archived.length} session(s)`);
    console.log(`   Location: ${options.sessionDir}/archive/${new Date().toISOString().split('T')[0]}/\n`);
  }

  if (results.failed.length > 0) {
    console.log(`‚ùå Failed to archive ${results.failed.length} session(s):`);
    results.failed.forEach(f => {
      console.log(`   ${f.sessionId}: ${f.reason}`);
    });
    console.log('');
  }
}

/**
 * Restore-prompt command: Manage session restoration prompts
 */
function restorePromptCommand(options) {
  const {
    hasRestorePrompt,
    loadRestorePrompt,
    deleteRestorePrompt,
    listRestorePrompts,
    editRestorePrompt,
    getRestorePromptInfo,
    formatRestorePromptInfo,
    isRestorePromptEnabled,
    disableRestorePrompt,
    enableRestorePrompt,
    getRestorePromptStatus,
    formatRestorePromptStatus
  } = require('../lib/restoration');

  const action = process.argv[3]; // restore-prompt <action>
  
  if (!action) {
    console.error('‚ùå Action required for restore-prompt command');
    console.error('   Available actions: edit, show, info, list, test, delete');
    console.error('   Example: tide-watch restore-prompt edit');
    process.exit(1);
  }

  switch (action) {
    case 'edit':
      // Edit restoration prompt
      if (!options.session) {
        console.error('‚ùå --session <key> required for edit command');
        console.error('   Example: tide-watch restore-prompt edit --session abc123');
        process.exit(1);
      }

      console.log(`Opening editor for session ${options.session}...\n`);
      const success = editRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (success) {
        console.log(`\n‚úÖ Restoration prompt saved for session ${options.session}`);
        console.log(`   Location: ${options.sessionDir}/restore-prompts/${options.session}.md\n`);
      }
      break;

    case 'show':
      // Show restoration prompt
      if (!options.session) {
        console.error('‚ùå --session <key> required for show command');
        console.error('   Example: tide-watch restore-prompt show --session abc123');
        process.exit(1);
      }

      const prompt = loadRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (!prompt) {
        console.log(`No restoration prompt found for session ${options.session}`);
        console.log(`Create one with: tide-watch restore-prompt edit --session ${options.session}\n`);
      } else {
        console.log(`\nRestoration Prompt for ${options.session}:\n`);
        console.log('‚îÄ'.repeat(70));
        console.log(prompt);
        console.log('‚îÄ'.repeat(70));
        console.log('');
      }
      break;

    case 'info':
      // Show restoration prompt metadata
      if (!options.session) {
        console.error('‚ùå --session <key> required for info command');
        console.error('   Example: tide-watch restore-prompt info --session abc123');
        process.exit(1);
      }

      const info = getRestorePromptInfo(options.session, options.sessionDir + '/restore-prompts');
      
      if (!info) {
        console.log(`No restoration prompt found for session ${options.session}\n`);
      } else {
        console.log(`\nRestoration Prompt Info:\n`);
        console.log(formatRestorePromptInfo(info));
        console.log('');
      }
      break;

    case 'list':
      // List all restoration prompts
      const prompts = listRestorePrompts(options.sessionDir + '/restore-prompts');
      
      if (prompts.length === 0) {
        console.log('No restoration prompts found.');
        console.log('Create one with: tide-watch restore-prompt edit --session <session-id>\n');
      } else {
        const disabledCount = prompts.filter(p => !p.enabled).length;
        
        console.log(`\nRestoration Prompts:\n`);
        console.log('Session ID        Size       Modified    Status');
        console.log('‚îÄ'.repeat(70));
        
        prompts.forEach(p => {
          const id = p.sessionId.substring(0, 16).padEnd(17);
          const size = `${p.size} bytes`.padEnd(10);
          const modified = p.modified.toLocaleDateString().padEnd(11);
          const status = p.enabled ? '‚úÖ Enabled' : '‚è∏Ô∏è  Disabled';
          console.log(`${id} ${size} ${modified} ${status}`);
        });
        
        console.log('');
        
        if (disabledCount > 0) {
          console.log(`Total: ${prompts.length} restoration prompt(s) (${disabledCount} disabled)\n`);
        } else {
          console.log(`Total: ${prompts.length} restoration prompt(s)\n`);
        }
      }
      break;

    case 'test':
      // Test restoration prompt (dry-run)
      if (!options.session) {
        console.error('‚ùå --session <key> required for test command');
        console.error('   Example: tide-watch restore-prompt test --session abc123');
        process.exit(1);
      }

      const testPrompt = loadRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (!testPrompt) {
        console.log(`No restoration prompt found for session ${options.session}\n`);
      } else {
        console.log(`\nüß™ Testing restoration prompt for ${options.session}:\n`);
        console.log('‚îÄ'.repeat(70));
        console.log(testPrompt);
        console.log('‚îÄ'.repeat(70));
        
        const tokenEstimate = Math.ceil(testPrompt.length / 4);
        console.log(`\nEstimated tokens: ~${tokenEstimate}`);
        
        if (tokenEstimate > 1000) {
          console.log('‚ö†Ô∏è  Warning: Prompt is large (>1000 tokens). Consider shortening.');
        } else {
          console.log('‚úÖ Prompt size looks good.');
        }
        console.log('');
      }
      break;

    case 'delete':
      // Delete restoration prompt
      if (!options.session) {
        console.error('‚ùå --session <key> required for delete command');
        console.error('   Example: tide-watch restore-prompt delete --session abc123');
        process.exit(1);
      }

      const deleted = deleteRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (deleted) {
        console.log(`‚úÖ Deleted restoration prompt for session ${options.session}\n`);
      } else {
        console.log(`No restoration prompt found for session ${options.session}\n`);
      }
      break;

    case 'enable':
      // Enable restoration prompt
      if (!options.session) {
        console.error('‚ùå --session <key> required for enable command');
        console.error('   Example: tide-watch restore-prompt enable --session abc123');
        process.exit(1);
      }

      const enabled = enableRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (enabled) {
        console.log(`‚úÖ Enabled restoration prompt for session ${options.session}`);
        console.log(`   Auto-load will activate on session reset`);
        console.log(`   Location: ${options.sessionDir}/restore-prompts/${options.session}.md\n`);
      } else {
        console.log(`No restoration prompt found for session ${options.session}`);
        console.log(`Create one with: tide-watch restore-prompt edit --session ${options.session}\n`);
      }
      break;

    case 'disable':
      // Disable restoration prompt
      if (!options.session) {
        console.error('‚ùå --session <key> required for disable command');
        console.error('   Example: tide-watch restore-prompt disable --session abc123');
        process.exit(1);
      }

      const disabled = disableRestorePrompt(options.session, options.sessionDir + '/restore-prompts');
      
      if (disabled) {
        console.log(`‚úÖ Disabled restoration prompt for session ${options.session}`);
        console.log(`   Prompt file preserved: ${options.sessionDir}/restore-prompts/${options.session}.md`);
        console.log(`   Auto-load will be skipped on session reset`);
        console.log('');
        console.log(`   To re-enable: tide-watch restore-prompt enable --session ${options.session}\n`);
      } else {
        console.log(`No restoration prompt found for session ${options.session}\n`);
      }
      break;

    case 'status':
      // Show restoration prompt status
      if (!options.session) {
        console.error('‚ùå --session <key> required for status command');
        console.error('   Example: tide-watch restore-prompt status --session abc123');
        process.exit(1);
      }

      const statusInfo = getRestorePromptStatus(options.session, options.sessionDir + '/restore-prompts');
      
      if (!statusInfo) {
        console.log(`\nNo restoration prompt found for session ${options.session}`);
        console.log(`Create one with: tide-watch restore-prompt edit --session ${options.session}\n`);
      } else {
        console.log(`\nRestoration Prompt Status:\n`);
        console.log(formatRestorePromptStatus(statusInfo));
        console.log('');
      }
      break;

    default:
      console.error(`Unknown restore-prompt action: ${action}`);
      console.error('Available actions: edit, show, info, list, test, delete, enable, disable, status');
      process.exit(1);
  }
}

/**
 * Main entry point
 */
function main() {
  const options = parseArgs();

  switch (options.command) {
    case 'check':
      checkCommand(options);
      break;
    case 'report':
      reportCommand(options);
      break;
    case 'dashboard':
      dashboardCommand(options);
      break;
    case 'archive':
      archiveCommand(options);
      break;
    case 'restore-prompt':
      restorePromptCommand(options);
      break;
    case 'status':
      statusCommand(options);
      break;
    case 'help':
    case '--help':
    case '-h':
      console.log(USAGE);
      break;
    default:
      console.error(`Unknown command: ${options.command}`);
      console.log(USAGE);
      process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  main();
}

module.exports = { main, parseArgs };
